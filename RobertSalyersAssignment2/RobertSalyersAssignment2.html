<!DOCTYPE html>
<html>
<body>
  <canvas width="500" height="500" id="glCanvas"></canvas>

  <script>
    // Setup WebGL
    const canvas = document.getElementById("glCanvas");
    const gl = canvas.getContext("webgl");

    // Shader sources
    const vertShaderSrcCode = `
      attribute vec3 aPosition;
      attribute vec3 aColor;
      varying vec3 vColor;

      void main() {
          gl_Position = vec4(aPosition, 1.0);
          vColor = aColor;
      }
    `;

    const fragShaderSrcCode = `
      precision mediump float;
      varying vec3 vColor;

      void main() {
          gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    // Compile and link
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertShdr = createShader(gl, gl.VERTEX_SHADER, vertShaderSrcCode);
    const fragShdr = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSrcCode);

    const program = gl.createProgram();
    gl.attachShader(program, vertShdr);
    gl.attachShader(program, fragShdr);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    // Shapes system
    const shapes = [];

    function addShape(vertices, colors) {
      const vBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const cBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

      shapes.push({
        vBuffer,
        cBuffer,
        vertexCount: vertices.length / 3,
      });
    }

    function renderScene() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      shapes.forEach(shape => {
        // Position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.vBuffer);
        const positionLoc = gl.getAttribLocation(program, "aPosition");
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        // Color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.cBuffer);
        const colorLoc = gl.getAttribLocation(program, "aColor");
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, shape.vertexCount);
      });
    }

    // Create triangle functions
    function createTriangle(x0, y0, x1, y1, x2, y2, color) {
        const vertices = new Float32Array([
            x0, y0, 0,
            x1, y1, 0,
            x2, y2, 0
        ]); 

        const colors = new Float32Array([
            ...color, ...color, ...color
        ]);

        return { vertices, colors };
    }

    // Create rectangle functions
    function createRectangle(x0, y0, x1, y1, color) {
        const vertices = new Float32Array([
            x0, y0, 0,
            x0, y1, 0,
            x1, y1, 0,

            x0, y0, 0,
            x1, y0, 0,
            x1, y1, 0
        ]); 

        const colors = new Float32Array([
            ...color, ...color, ...color,
            ...color, ...color, ...color
        ]);

        return { vertices, colors };
    }
        


    // Brick wall generator with half-bricks on edges
    function createBrickWall(x, y, wallWidth, wallHeight, rows, cols) {
    const vertices = [];
    const colors = [];

    const brickW = wallWidth / cols;
    const brickH = wallHeight / rows;

    for (let row = 0; row < rows; row++) {
        const isOffset = row % 2 === 1;
        const bricksInRow = isOffset ? cols + 1 : cols; // add one for half-bricks
        for (let col = 0; col < bricksInRow; col++) {
        let brickX0 = x + col * brickW - (isOffset ? brickW / 2 : 0);
        let brickX1 = brickX0 + brickW;
        let brickY0 = y + row * brickH;
        let brickY1 = brickY0 + brickH;

        // Skip anything outside wall bounds
        if (brickX0 < x) brickX0 = x;
        if (brickX1 > x + wallWidth) brickX1 = x + wallWidth;

        // Two triangles per brick
        vertices.push(
            brickX0, brickY0, 0,
            brickX1, brickY0, 0,
            brickX1, brickY1, 0,

            brickX0, brickY0, 0,
            brickX1, brickY1, 0,
            brickX0, brickY1, 0
        );

        // Random reddish color
        const r = 0.6 + Math.random() * 0.4;
        const g = Math.random() * 0.3;
        const b = Math.random() * 0.3;
        const brickColor = [r, g, b];

        for (let i = 0; i < 6; i++) {
            colors.push(...brickColor);
        }
        }
    }

    return {
        vertices: new Float32Array(vertices),
        colors: new Float32Array(colors)
    };
    }

    // Scene setup
    gl.clearColor(0.0, 0.0, 0.5, 1.0);
    gl.enable(gl.DEPTH_TEST);

    // Windows
    // Segment windows first for layers
    const windowbar1 = createRectangle(-0.5, -0.425, -0.8, -0.475, [0.2, 0.2, 0.2]);
    const windowbar2 = createRectangle(-0.675, -0.3, -0.625, -0.6, [0.2, 0.2, 0.2]);
    addShape(windowbar1.vertices, windowbar1.colors);
    addShape(windowbar2.vertices, windowbar2.colors);

    const windows = createRectangle(-0.5, -0.3, -0.8, -0.6, [0.9, 0.9, 0.9]);
    addShape(windows.vertices, windows.colors);

    // Door door
    const rectDoor = createRectangle(-0.4, -0.9, -0.1, -0.3, [0.0, 0.5, 0.0]);
    addShape(rectDoor.vertices, rectDoor.colors);

    // Garage door lines
    const garline1 = createRectangle(0.0, -0.7, 0.8, -0.715, [0.2, 0.2, 0.2]);
    const garline2 = createRectangle(0.0, -0.5, 0.8, -0.515, [0.2, 0.2, 0.2]);
    const garline3 = createRectangle(0.0, -0.3, 0.8, -0.315, [0.2, 0.2, 0.2]);

    addShape(garline1.vertices, garline1.colors);
    addShape(garline2.vertices, garline2.colors);
    addShape(garline3.vertices, garline3.colors);

    // Garage door
    const garage = createRectangle(0.0, -0.9, 0.8, -0.2, [0.8, 0.8, 0.8]);
    addShape(garage.vertices, garage.colors);

    // Wall of bricks
    const wall = createBrickWall(-0.9, -0.9, 1.8, 0.9, 6, 12);
    addShape(wall.vertices, wall.colors);

    // Triangle Roof
    const triangleRoof = createTriangle(0.25, 0.5, -0.4, 0.0, 0.9, 0.0, [0.7, 0.7, 0.7]);
    const triangleRoof2 = createTriangle(0.25, 0.6, -0.5, 0.0, 1.0, 0.0, [0.75, 0.25, 0.0]);
    addShape(triangleRoof.vertices, triangleRoof.colors);
    addShape(triangleRoof2.vertices, triangleRoof2.colors);

    // Square part of the roof to show a turn
    const rectRoof = createRectangle(-1.0, 0.0, 0.25, 0.6, [0.6, 0.25, 0.0]);
    addShape(rectRoof.vertices, rectRoof.colors);

    // Render
    renderScene();
  </script>
  <script src="snow.js"></script>
</body>
</html>
